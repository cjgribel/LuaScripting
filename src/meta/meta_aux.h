//
//  meta_apply.h
//
//  Created by Carl Johan Gribel on 2024-08-08.
//  Copyright Â© 2024 Carl Johan Gribel. All rights reserved.
//

#ifndef any_apply_h
#define any_apply_h

#include <entt/entt.hpp>
#include <tuple>
#include <utility>
#include <cassert>

namespace internal {

template<typename T, typename Callable>
bool try_apply(entt::meta_any &value, Callable callable) 
{
    if (auto *ptr = value.try_cast<T>(); ptr) {
        callable(*ptr);
        return true;
    }
    return false;
}

template<typename Callable, typename... Types>
bool any_apply_impl(entt::meta_any &value, Callable callable, std::tuple<Types...>) 
{
    bool result = false;
    (... || (result = try_apply<Types>(value, callable)));
    return result;
}

} // namespace internal

/// Tries to convert argument to a primitive type and, if successful, applies a function for it
template<typename Callable>
bool try_apply(entt::meta_any &value, Callable callable) 
{
    using Types = std::tuple<
        bool,
        char, unsigned char,
        short, unsigned short,
        int, unsigned int,
        long, unsigned long,
        long long, unsigned long long,
        float, double, long double
    >;

    return internal::any_apply_impl(value, callable, Types{});
}

/// Returns either 1) the display name or 2) the default-assigned name of the argument
inline auto any_name(const entt::meta_any any)
{
    assert(any);
    
    // Use display name if present, assumed to be in C-string format
    if (auto meta_type = entt::resolve(any.type().id()); meta_type)
        if (auto name_prop = meta_type.prop(display_name_hs); name_prop)
            if (auto name = name_prop.value().cast<const char*>(); name)
                return std::string(name);
    
    // Use the name generated by entt
    return std::string(any.type().info().name());
}

#endif /* any_visit_h */
